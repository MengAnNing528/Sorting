// Сортировка выбором - всегда O(n²)
void selectionsort(int* l, int* r) {
    for (int *i = l; i < r; i++) {        // n итераций
        for (int *j = i + 1; j < r; j++) { // n-i итераций
            if (*j < minz) ...             // O(1)
        }
    }
}
// Сложность: O(n²) всегда

// Сортировка пузырьком - O(n²) в худшем, O(n) в лучшем
void bubblesort(int* l, int* r) {
    while (b) {                           // до n итераций
        for (int* i = l; i + 1 < r; i++) { // n итераций
            if (*i > *(i + 1)) ...        // O(1)
        }
    }
}
// Сложность: O(n²) худший, O(n) лучший (уже отсортирован)

// Сортировка вставками - O(n²) в худшем, O(n) в лучшем
void insertionsort(int* l, int* r) {
    for (int *i = l + 1; i < r; i++) {   // n итераций
        while (j > l && *(j - 1) > *j) { // до i итераций
            swap(*(j - 1), *j);          // O(1)
        }
    }
}
// Сложность: O(n²) худший, O(n) лучший

// Сортировка слиянием - всегда O(n log n)
void _mergesort(int* l, int* r, int* temp) {
    if (r - l <= 1) return;               // O(1)
    _mergesort(l, m, temp);               // T(n/2)
    _mergesort(m, r, temp);               // T(n/2)
    merge(l, m, r, temp);                 // O(n)
}
// Рекуррентность: T(n) = 2T(n/2) + O(n) → O(n log n)

// Быстрая сортировка - O(n log n) в среднем, O(n²) в худшем
void quicksort(int* l, int* r) {
    quicksort(l, rr + 1);                 // T(k)
    quicksort(ll, r);                     // T(n-k-1)
}
// Сложность: O(n log n) средний, O(n²) худший (уже отсортирован)

// Пирамидальная сортировка - всегда O(n log n)
void heapsort(int* l, int* r) {
    for (int *i = l; i < r; i++) h.push(*i); // n × O(log n)
    for (int *i = l; i < r; i++) h.pop();    // n × O(log n)
}
// Сложность: O(n log n)

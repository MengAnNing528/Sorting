//Сортировка выбором / Selection sort; O(n2)
void selectionsort(int* l, int* r) {
	for (int *i = l; i < r; i++) {
		int minz = *i, *ind = i;
		for (int *j = i + 1; j < r; j++) {
			if (*j < minz) minz = *j, ind = j;
		}
		swap(*i, *ind);
	}
}

//Сортировка обменом (пузырьком) / Bubble sort; O(n2)/O(n)
void bubblesort(int* l, int* r) {
	int sz = r - l;
	if (sz <= 1) return;
	bool b = true;
	while (b) {
		b = false;
		for (int* i = l; i + 1 < r; i++) {
			if (*i > *(i + 1)) {
				swap(*i, *(i + 1));
				b = true;
			}
		}
		r--;
	}
}

//Сортировка вставками / Insertion sort; O(n2)/O(n)
void insertionsort(int* l, int* r) {
	for (int *i = l + 1; i < r; i++) {
		int* j = i;
		while (j > l && *(j - 1) > *j) {
			swap(*(j - 1), *j);
			j--;
		}
	}
}

//Сортировка слиянием / Merge sort; «разделяй и властвуй»; Слияние работает за O(n), уровней всего logn, поэтому асимптотика O(nlogn)
void insertionsort(int* l, int* r) {
    for (int* i = l + 1; i < r; i++) {
        int key = *i;
        int* j = i - 1;
        
        // Move elements greater than key one position ahead
        while (j >= l && *j > key) {
            *(j + 1) = *j;
            j--;
        }
        *(j + 1) = key;
    }
}

void merge(int* l, int* m, int* r, int* temp) {
    int *cl = l, *cr = m, cur = 0;
    while (cl < m && cr < r) {
        if (*cl < *cr) temp[cur++] = *cl, cl++;
        else temp[cur++] = *cr, cr++;
    }
    while (cl < m) temp[cur++] = *cl, cl++;
    while (cr < r) temp[cur++] = *cr, cr++;
    cur = 0;
    for (int* i = l; i < r; i++)
        *i = temp[cur++];
}

void _mergesort(int* l, int* r, int* temp) {
    if (r - l <= 1) return;
    int *m = l + (r - l) / 2;
    _mergesort(l, m, temp);
    _mergesort(m, r, temp);
    merge(l, m, r, temp);
}

void mergesort(int* l, int* r) {
    int* temp = new int[r - l];
    _mergesort(l, r, temp);
    delete[] temp;  // Fixed: use delete[] instead of delete
}

void _mergeinssort(int* l, int* r, int* temp) {
    if (r - l <= 32) {
        insertionsort(l, r);  // Now this function exists
        return;
    }
    int *m = l + (r - l) / 2;
    _mergeinssort(l, m, temp);
    _mergeinssort(m, r, temp);
    merge(l, m, r, temp);
}

void mergeinssort(int* l, int* r) {
    int* temp = new int[r - l];
    _mergeinssort(l, r, temp);
    delete[] temp;  // Fixed: use delete[] instead of delete
}

//Сортировка Шелла / Shellsort; O(n2)
void shellsort(int* l, int* r) {
	int sz = r - l;
	int step = sz / 2;
	while (step >= 1) {
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
		step /= 2;
	}
}
void shellsorthib(int* l, int* r) {
	int sz = r - l;
	if (sz <= 1) return;
	int step = 1;
	while (step < sz) step <<= 1;
	step >>= 1;
	step--;
	while (step >= 1) {
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
		step /= 2;
	}
}
int steps[100];
void shellsortsedgwick(int* l, int* r) {
	int sz = r - l;
	steps[0] = 1;
	int q = 1;
	while (steps[q - 1] * 3 < sz) {
		if (q % 2 == 0)
			steps[q] = 9 * (1 << q) - 9 * (1 << (q / 2)) + 1;
		else
			steps[q] = 8 * (1 << q) - 6 * (1 << ((q + 1) / 2)) + 1;
		q++;
	}
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}
void shellsortpratt(int* l, int* r) {
	int sz = r - l;
	steps[0] = 1;
	int cur = 1, q = 1;
	for (int i = 1; i < sz; i++) {
		int cur = 1 << i;
		if (cur > sz / 2) break;
		for (int j = 1; j < sz; j++) {
			cur *= 3;
			if (cur > sz / 2) break;
			steps[q++] = cur;
		}
	}
	insertionsort(steps, steps + q);
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}
void myshell1(int* l, int* r) {
	int sz = r - l, q = 1;
	steps[0] = 1;
	while (steps[q - 1] < sz) {
		int s = steps[q - 1];
		steps[q++] = s * 4 + s / 4;
	}
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}
void myshell2(int* l, int* r) {
	int sz = r - l, q = 1;
	steps[0] = 1;
	while (steps[q - 1] < sz) {
		int s = steps[q - 1];
		steps[q++] = s * 3 + s / 3;
	}
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}
void myshell3(int* l, int* r) {
	int sz = r - l, q = 1;
	steps[0] = 1;
	while (steps[q - 1] < sz) {
		int s = steps[q - 1];
		steps[q++] = s * 4 - s / 5;
	}
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}

//Быстрая сортировка / Quicksort; O(nlogn), O(n2)
void quicksort(int* l, int* r) {
	if (r - l <= 1) return;
	int z = *(l + (r - l) / 2);
	int* ll = l, *rr = r - 1;
	while (ll <= rr) {
		while (*ll < z) ll++;
		while (*rr > z) rr--;
		if (ll <= rr) {
			swap(*ll, *rr);
			ll++;
			rr--;
		}
	}
	if (l < rr) quicksort(l, rr + 1);
	if (ll < r) quicksort(ll, r);
}
void quickinssort(int* l, int* r) {
	if (r - l <= 32) {
		insertionsort(l, r);
		return;
	}
	int z = *(l + (r - l) / 2);
	int* ll = l, *rr = r - 1;
	while (ll <= rr) {
		while (*ll < z) ll++;
		while (*rr > z) rr--;
		if (ll <= rr) {
			swap(*ll, *rr);
			ll++;
			rr--;
		}
	}
	if (l < rr) quickinssort(l, rr + 1);
	if (ll < r) quickinssort(ll, r);
}

//Пирамидальная сортировка / Heapsort; O(1), O(logn)
template <class T>
class heap {
public:
	int size() {
		return n;
	}
	int top() {
		return h[0];
	}
	bool empty() {
		return n == 0;
	}
	void push(T a) {
		h.push_back(a);
		SiftUp(n);
		n++;
	}
	void pop() {
		n--;
		swap(h[n], h[0]);
		h.pop_back();
		SiftDown(0);
	}
	void clear() {
		h.clear();
		n = 0;
	}
	T operator [] (int a) {
		return h[a];
	}
private:
	vector<T> h;
	int n = 0;
	void SiftUp(int a) {
		while (a) {
			int p = (a - 1) / 2;
			if (h[p] > h[a]) swap(h[p], h[a]);
			else break;
			a--; a /= 2;
		}
	}
	void SiftDown(int a) {
		while (2 * a + 1 < n) {
			int l = 2 * a + 1, r = 2 * a + 2;
			if (r == n) {
				if (h[l] < h[a]) swap(h[l], h[a]);
				break;
			}
			else if (h[l] <= h[r]) {
				if (h[l] < h[a]) {
					swap(h[l], h[a]);
					a = l;
				}
				else break;
			}
			else if (h[r] < h[a]) {
				swap(h[r], h[a]);
				a = r;
			}
			else break;
		}
	}
};
void heapsort(int* l, int* r) {
	heap<int> h;
	for (int *i = l; i < r; i++) h.push(*i);
	for (int *i = l; i < r; i++) {
		*i = h.top();
		h.pop();
	}
}

//Последовательный поиск / Sequential Search; O(N)
package com.vogella.algorithms.search.sequential;
public class SequentialSearch {
    public static boolean contains(int[] a, int b) {
        for (int i : a) {
            if (i == b) {
                return true;
            }
        }
        return false;
    }
}

//Бинарный поиск / Binary Search; O(log N)
class Geeks{
    
    static int binarySearch(int a[], int l, int r, int x){
        
        while (l <= r){
            
            int m = (l + r) / 2;

            // Index of Element Returned
            if (a[m] == x) {
                return m;

                // If element is smaller than mid, then
                // it can only be present in left subarray
                // so we decrease our r pointer to mid - 1
            }
            else if (a[m] > x) {
                r = m - 1;

                // Else the element can only be present
                // in right subarray
                // so we increase our l pointer to mid + 1
            }
            else {
                l = m + 1;
            }
        }

        // No Element Found
        return -1;
    }

    public static void main(String args[])
    {

        int a[] = { 2, 3, 4, 10, 40 };
        int n = a.length;
        int x = 10;

        int res = binarySearch(a, 0, n - 1, x);

        System.out.println("Element to be searched is : "
                           + x);

        if (res == -1)
            System.out.println(
                "Element is not present in array");
        else
            System.out.println(
                "Element is present at index: " + res);
    }
}

//Интерполирующий поиск / Interpolation Search; O(n), O(log n)
// Java program to implement interpolation
// search with recursion
import java.util.*;

class GFG {

    // If x is present in arr[0..n-1], then returns
    // index of it, else returns -1.
    public static int interpolationSearch(int arr[], int lo,
                                          int hi, int x)
    {
        int pos;

        // Since array is sorted, an element
        // present in array must be in range
        // defined by corner
        if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {

            // Probing the position with keeping
            // uniform distribution in mind.
            pos = lo
                  + (((hi - lo) / (arr[hi] - arr[lo]))
                     * (x - arr[lo]));

            // Condition of target found
            if (arr[pos] == x)
                return pos;

            // If x is larger, x is in right sub array
            if (arr[pos] < x)
                return interpolationSearch(arr, pos + 1, hi,
                                           x);

            // If x is smaller, x is in left sub array
            if (arr[pos] > x)
                return interpolationSearch(arr, lo, pos - 1,
                                           x);
        }
        return -1;
    }

    // Driver Code
    public static void main(String[] args)
    {

        // Array of items on which search will
        // be conducted.
        int arr[] = { 10, 12, 13, 16, 18, 19, 20, 21,
                      22, 23, 24, 33, 35, 42, 47 };

        int n = arr.length;

        // Element to be searched
        int x = 18;
        int index = interpolationSearch(arr, 0, n - 1, x);

        // If element was found
        if (index != -1)
            System.out.println("Element found at index "
                               + index);
        else
            System.out.println("Element not found.");
    }
}

//Фибоначи поиск / Fibonacci Search; O(log n) Time and O(1) Space
import java.io.*;

class GfG {

    // Returns index of x if present, else returns -1
    public static int search(int[] arr, int x) {
        int n = arr.length;

        // initialize first three fibonacci numbers
        int a =  0, b = 1, c = 1;
 
        // iterate while c is smaller than n
        // c stores the smallest Fibonacci 
        // number greater than or equal to n
        while (c < n) {
            a = b;
            b = c;
            c = a + b;
        }
 
        // marks the eliminated range from front
        int offset = -1;
 
        // while there are elements to be inspected
        // Note that we compare arr[a] with x. 
        // When c becomes 1, a becomes 08
        while (c > 1) {

            // check if a is a valid location
            int i = Math.min(offset + a, n - 1);
 
            // if x is greater than the value at index a,
            // cut the subarray array from offset to i 
            if (arr[i] < x) {
                c = b;
                b = a;
                a = c - b;
                offset = i;
            }
 
            // else if x is greater than the value at 
            // index a,cut the subarray after i+1
            else if (arr[i] > x) {
                c = a;
                b = b - a;
                a = c - b;
            }
 
            // else if element found, return index
            else
                return i;
        }
 
        // comparing the last element with x
        if (b != 0 && arr[offset + 1] == x)
            return offset + 1;
 
        // element not found, return -1
        return -1;
    }

    public static void main(String[] args) {
        int[] arr = {2, 3, 4, 10, 40};
        int x = 10;
        System.out.println(search(arr, x));
    }
}

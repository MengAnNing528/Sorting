//Сортировка выбором / Selection sort; O(n2)
void selectionsort(int* l, int* r) {
	for (int *i = l; i < r; i++) {
		int minz = *i, *ind = i;
		for (int *j = i + 1; j < r; j++) {
			if (*j < minz) minz = *j, ind = j;
		}
		swap(*i, *ind);
	}
}

//Сортировка обменом (пузырьком) / Bubble sort; O(n2)/O(n)
void bubblesort(int* l, int* r) {
	int sz = r - l;
	if (sz <= 1) return;
	bool b = true;
	while (b) {
		b = false;
		for (int* i = l; i + 1 < r; i++) {
			if (*i > *(i + 1)) {
				swap(*i, *(i + 1));
				b = true;
			}
		}
		r--;
	}
}

//Сортировка вставками / Insertion sort; O(n2)/O(n)
void insertionsort(int* l, int* r) {
	for (int *i = l + 1; i < r; i++) {
		int* j = i;
		while (j > l && *(j - 1) > *j) {
			swap(*(j - 1), *j);
			j--;
		}
	}
}

//Сортировка слиянием / Merge sort; «разделяй и властвуй»; Слияние работает за O(n), уровней всего logn, поэтому асимптотика O(nlogn)
void insertionsort(int* l, int* r) {
    for (int* i = l + 1; i < r; i++) {
        int key = *i;
        int* j = i - 1;
        
        // Move elements greater than key one position ahead
        while (j >= l && *j > key) {
            *(j + 1) = *j;
            j--;
        }
        *(j + 1) = key;
    }
}

void merge(int* l, int* m, int* r, int* temp) {
    int *cl = l, *cr = m, cur = 0;
    while (cl < m && cr < r) {
        if (*cl < *cr) temp[cur++] = *cl, cl++;
        else temp[cur++] = *cr, cr++;
    }
    while (cl < m) temp[cur++] = *cl, cl++;
    while (cr < r) temp[cur++] = *cr, cr++;
    cur = 0;
    for (int* i = l; i < r; i++)
        *i = temp[cur++];
}

void _mergesort(int* l, int* r, int* temp) {
    if (r - l <= 1) return;
    int *m = l + (r - l) / 2;
    _mergesort(l, m, temp);
    _mergesort(m, r, temp);
    merge(l, m, r, temp);
}

void mergesort(int* l, int* r) {
    int* temp = new int[r - l];
    _mergesort(l, r, temp);
    delete[] temp;  // Fixed: use delete[] instead of delete
}

void _mergeinssort(int* l, int* r, int* temp) {
    if (r - l <= 32) {
        insertionsort(l, r);  // Now this function exists
        return;
    }
    int *m = l + (r - l) / 2;
    _mergeinssort(l, m, temp);
    _mergeinssort(m, r, temp);
    merge(l, m, r, temp);
}

void mergeinssort(int* l, int* r) {
    int* temp = new int[r - l];
    _mergeinssort(l, r, temp);
    delete[] temp;  // Fixed: use delete[] instead of delete
}

//Сортировка Шелла / Shellsort; O(n2)
void shellsort(int* l, int* r) {
	int sz = r - l;
	int step = sz / 2;
	while (step >= 1) {
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
		step /= 2;
	}
}
void shellsorthib(int* l, int* r) {
	int sz = r - l;
	if (sz <= 1) return;
	int step = 1;
	while (step < sz) step <<= 1;
	step >>= 1;
	step--;
	while (step >= 1) {
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
		step /= 2;
	}
}
int steps[100];
void shellsortsedgwick(int* l, int* r) {
	int sz = r - l;
	steps[0] = 1;
	int q = 1;
	while (steps[q - 1] * 3 < sz) {
		if (q % 2 == 0)
			steps[q] = 9 * (1 << q) - 9 * (1 << (q / 2)) + 1;
		else
			steps[q] = 8 * (1 << q) - 6 * (1 << ((q + 1) / 2)) + 1;
		q++;
	}
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}
void shellsortpratt(int* l, int* r) {
	int sz = r - l;
	steps[0] = 1;
	int cur = 1, q = 1;
	for (int i = 1; i < sz; i++) {
		int cur = 1 << i;
		if (cur > sz / 2) break;
		for (int j = 1; j < sz; j++) {
			cur *= 3;
			if (cur > sz / 2) break;
			steps[q++] = cur;
		}
	}
	insertionsort(steps, steps + q);
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}
void myshell1(int* l, int* r) {
	int sz = r - l, q = 1;
	steps[0] = 1;
	while (steps[q - 1] < sz) {
		int s = steps[q - 1];
		steps[q++] = s * 4 + s / 4;
	}
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}
void myshell2(int* l, int* r) {
	int sz = r - l, q = 1;
	steps[0] = 1;
	while (steps[q - 1] < sz) {
		int s = steps[q - 1];
		steps[q++] = s * 3 + s / 3;
	}
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}
void myshell3(int* l, int* r) {
	int sz = r - l, q = 1;
	steps[0] = 1;
	while (steps[q - 1] < sz) {
		int s = steps[q - 1];
		steps[q++] = s * 4 - s / 5;
	}
	q--;
	for (; q >= 0; q--) {
		int step = steps[q];
		for (int *i = l + step; i < r; i++) {
			int *j = i;
			int *diff = j - step;
			while (diff >= l && *diff > *j) {
				swap(*diff, *j);
				j = diff;
				diff = j - step;
			}
		}
	}
}

//Быстрая сортировка / Quicksort; O(nlogn), O(n2)
void insertionsort(int* l, int* r) {
    for (int* i = l + 1; i < r; i++) {
        int key = *i;
        int* j = i - 1;
        
        // Move elements greater than key one position ahead
        while (j >= l && *j > key) {
            *(j + 1) = *j;
            j--;
        }
        *(j + 1) = key;
    }
}

void quicksort(int* l, int* r) {
    if (r - l <= 1) return;
    int z = *(l + (r - l) / 2);
    int* ll = l, *rr = r - 1;
    while (ll <= rr) {
        while (*ll < z) ll++;
        while (*rr > z) rr--;
        if (ll <= rr) {
            swap(*ll, *rr);
            ll++;
            rr--;
        }
    }
    if (l < rr) quicksort(l, rr + 1);
    if (ll < r) quicksort(ll, r);
}

void quickinssort(int* l, int* r) {
    if (r - l <= 32) {
        insertionsort(l, r);  // Now this function exists!
        return;
    }
    int z = *(l + (r - l) / 2);
    int* ll = l, *rr = r - 1;
    while (ll <= rr) {
        while (*ll < z) ll++;
        while (*rr > z) rr--;
        if (ll <= rr) {
            swap(*ll, *rr);
            ll++;
            rr--;
        }
    }
    if (l < rr) quickinssort(l, rr + 1);
    if (ll < r) quickinssort(ll, r);
}

//Пирамидальная сортировка / Heapsort; O(1), O(logn)
template <class T>
class heap {
public: 
    int size() {
        return n;
    }
    
    T top() {  // Changed return type from int to T for genericity
        if (empty()) throw runtime_error("Heap is empty");
        return h[0];
    }
    
    bool empty() {
        return n == 0;
    }
    
    void push(T a) {
        h.push_back(a);
        SiftUp(n);  // n is the index of the newly added element
        n++;
    }
    
    void pop() {
        if (empty()) throw runtime_error("Heap is empty");
        n--;
        if (n > 0) {  // Only swap if there are remaining elements
            swap(h[n], h[0]);
            h.pop_back();
            SiftDown(0);
        } else {
            h.pop_back();
        }
    }
    
    void clear() {
        h.clear();
        n = 0;
    }
    
    T operator[](int a) {
        if (a >= n) throw out_of_range("Index out of bounds");
        return h[a];
    }
    
private: 
    vector<T> h;
    int n = 0;
    
    void SiftUp(int a) {
        while (a > 0) {  // Changed condition for clarity
            int p = (a - 1) / 2;
            if (h[p] > h[a]) {
                swap(h[p], h[a]);
                a = p;  // Fixed: move to parent index
            } else {
                break;
            }
        }
    }
    
    void SiftDown(int a) {
        while (2 * a + 1 < n) {
            int l = 2 * a + 1, r = 2 * a + 2;
            int smallest = a;
            
            // Find the smallest among parent, left child, and right child
            if (l < n && h[l] < h[smallest]) {
                smallest = l;
            }
            if (r < n && h[r] < h[smallest]) {
                smallest = r;
            }
            
            if (smallest != a) {
                swap(h[a], h[smallest]);
                a = smallest;
            } else {
                break;
            }
        }
    }
};

void heapsort(int* l, int* r) {
    heap<int> h;
    for (int *i = l; i < r; i++) {
        h.push(*i);
    }
    for (int *i = l; i < r; i++) {
        *i = h.top();
        h.pop();
    }
}

//Последовательный поиск / Sequential Search; O(N)
package com.vogella.algorithms.search.sequential;
public class SequentialSearch {
    public static boolean contains(int[] a, int b) {
        for (int i : a) {
            if (i == b) {
                return true;
            }
        }
        return false;
    }
}

//Бинарный поиск / Binary Search; O(log N)
class Geeks {
public:
    // Binary search function - made public and non-static for clarity
    static int binarySearch(int a[], int l, int r, int x) {
        while (l <= r) {
            int m = (l + r) / 2;

            // Index of Element Returned
            if (a[m] == x) {
                return m;
            }
            // If element is smaller than mid, then
            // it can only be present in left subarray
            // so we decrease our r pointer to mid - 1
            else if (a[m] > x) {
                r = m - 1;
            }
            // Else the element can only be present
            // in right subarray
            // so we increase our l pointer to mid + 1
            else {
                l = m + 1;
            }
        }

        // No Element Found
        return -1;
    }

    // C++ style test function
    static void testBinarySearch() {
        int a[] = {2, 3, 4, 10, 40};
        int n = sizeof(a) / sizeof(a[0]);  // C++ way to get array length
        int x = 10;

        int res = binarySearch(a, 0, n - 1, x);

        cout << "Element to be searched is: " << x << endl;

        if (res == -1)
            cout << "Element is not present in array" << endl;
        else
            cout << "Element is present at index: " << res << endl;
    }
};

//Интерполирующий поиск / Interpolation Search; O(n), O(log n)
// Java program to implement interpolation
// search with recursion
class SearchAlgorithms {
public:
    // Interpolation Search implementation in C++
    // Returns index if x is present, otherwise returns -1
    static int interpolationSearch(int arr[], int lo, int hi, int x) {
        int pos;

        // Since array is sorted, an element present in array 
        // must be in range defined by corner elements
        if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {
            // Probing the position with keeping uniform distribution in mind
            // Avoid division by zero
            if (arr[hi] == arr[lo]) {
                return (arr[lo] == x) ? lo : -1;
            }
            
            pos = lo + ((double)(x - arr[lo]) / (arr[hi] - arr[lo])) * (hi - lo);

            // Condition of target found
            if (arr[pos] == x)
                return pos;

            // If x is larger, x is in right sub array
            if (arr[pos] < x)
                return interpolationSearch(arr, pos + 1, hi, x);

            // If x is smaller, x is in left sub array
            if (arr[pos] > x)
                return interpolationSearch(arr, lo, pos - 1, x);
        }
        return -1;
    }

    // Binary Search implementation for comparison
    static int binarySearch(int arr[], int lo, int hi, int x) {
        if (hi >= lo) {
            int mid = lo + (hi - lo) / 2;

            if (arr[mid] == x)
                return mid;

            if (arr[mid] > x)
                return binarySearch(arr, lo, mid - 1, x);

            return binarySearch(arr, mid + 1, hi, x);
        }
        return -1;
    }

    // Test function for search algorithms
    static void testSearchAlgorithms() {
        cout << "=== Testing Search Algorithms ===" << endl;
        
        // Array of items on which search will be conducted
        int arr[] = {10, 12, 13, 16, 18, 19, 20, 21, 
                     22, 23, 24, 33, 35, 42, 47};
        
        int n = sizeof(arr) / sizeof(arr[0]);
        
        // Display the array
        cout << "Array: ";
        for (int i = 0; i < n; i++) {
            cout << arr[i] << " ";
        }
        cout << endl;

        // Element to be searched
        int x = 18;
        
        // Test Interpolation Search
        int interpIndex = interpolationSearch(arr, 0, n - 1, x);
        cout << "\nInterpolation Search for " << x << ": ";
        if (interpIndex != -1)
            cout << "Element found at index " << interpIndex << endl;
        else
            cout << "Element not found." << endl;

        // Test Binary Search
        int binaryIndex = binarySearch(arr, 0, n - 1, x);
        cout << "Binary Search for " << x << ": ";
        if (binaryIndex != -1)
            cout << "Element found at index " << binaryIndex << endl;
        else
            cout << "Element not found." << endl;
    }
};

//Фибоначи поиск / Fibonacci Search; O(log n) Time and O(1) Space
class SearchAlgorithms {
public:
    // Fibonacci Search implementation
    static int fibonacciSearch(int arr[], int n, int x) {
        // Initialize first three Fibonacci numbers
        int a = 0, b = 1, c = 1;
        
        // Find the smallest Fibonacci number greater than or equal to n
        while (c < n) {
            a = b;
            b = c;
            c = a + b;
        }
        
        // Marks the eliminated range from front
        int offset = -1;
        
        // While there are elements to be inspected
        while (c > 1) {
            // Check if 'a' is a valid location
            int i = min(offset + a, n - 1);
            
            // If x is greater than the value at index i,
            // cut the subarray from offset to i
            if (arr[i] < x) {
                c = b;
                b = a;
                a = c - b;
                offset = i;
            }
            // If x is smaller than the value at index i,
            // cut the subarray after i+1
            else if (arr[i] > x) {
                c = a;
                b = b - a;
                a = c - b;
            }
            // Element found, return index
            else {
                return i;
            }
        }
        
        // Compare the last element with x
        if (b != 0 && offset + 1 < n && arr[offset + 1] == x) {
            return offset + 1;
        }
        
        // Element not found
        return -1;
    }
    
    // Binary Search implementation
    static int binarySearch(int arr[], int low, int high, int x) {
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (arr[mid] == x) {
                return mid;
            }
            else if (arr[mid] < x) {
                low = mid + 1;
            }
            else {
                high = mid - 1;
            }
        }
        return -1;
    }
